# 是什么

### 读写锁说明

ReentrantReadWriteLock

读写锁定义为：<font color = 'blue'>一个资源能够被</font><font color = 'red'>多个读线程</font>访问，<font color = 'blue'>或者被</font><font color = 'red'>一个写线程</font><font color = 'blue'>访问</font>，<font color = 'blue'>但是不能同时存在读写线程。</font>即读写互斥，读读共享。

### 读写锁ReentrantReadWriteLock的意义和特点

<font color = 'red'>它只允许读读共存，而读写和写写依然是互斥的</font>，大多实际场景是<font color = 'red'>“读/读”线程间并不存在互斥关系</font>，

只有"读/写”线程或”写/写”线程间的操作需要五斥的。因此引入ReentrantReadWriteLock。

一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，<font color = 'red'>但不能同时存在写锁和读锁</font>，也即<font color = 'red'>一个资源可以被多个读操作访问或一个写操作访问</font>，但两者不能同时进行。

只有在读多写少情景之下，读写锁才具有较高的性能体现。

# 特点

<font color = 'red'>一体两面，读写互斥，读读共享，读没有完成时候其他线程写锁无法获得</font>

### 写锁 -> 读锁，ReentrantReadWriteLock可以降级

#### 《Java并发编程的艺术》中关于锁降级的说明

ReentrantReadWriteLock锁降级: 将写入锁降级为读锁(类似Linux文件读写权限理解，就像写权限要高于读权限一样)，锁的严苛程度变强叫做升级，反之叫做降级。

![image-20230813144049970](images/1.锁降级.png)

<font color = 'blue'>写锁的降级，降级成为了读锁</font>

1 如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。

2 规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。

3 如果释放了写锁，那么就完全转换为读锁。

#### 读写锁降级演示

写锁可以降级，锁降级是为了让当前线程感知到数据的变化，目的是保证数据可见性。

锁降级：遵循获取写锁 -> 再获取读锁 -> 再释放写锁的次序，写锁能够降级成为读锁。

如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。

![](images/2.写锁转换成读锁.jpg)

![](images/2.Java8官网说明.jpg)













